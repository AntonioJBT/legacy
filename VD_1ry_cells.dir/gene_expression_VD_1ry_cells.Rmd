---
Title: "Gene expression vitamin D primary cells"
Author: "Antonio Berlanga-Taylor"
Date: "10 Feb 2015"
Output: html_document
---

#############################
Check Limma's users guide, p. 20, Section 9 Single-Channel Experimental Designs on p.40, and case study in Section 17.3 on p.108:
http://www.bioconductor.org/packages/release/bioc/vignettes/limma/inst/doc/usersguide.pdf

Also check:
- Blog with simple instructions:
http://gettinggeneticsdone.blogspot.co.uk/2014/12/importing-illumina-beadarray-data-into-r.html?m=1

- BeadArray Expression Analysis Using Bioconductor paper in PLoS Comp Bio:
www.ploscompbiol.org/article/fetchObject.action?uri=info:doi/10.1371/journal.pcbi.1002276&representation=PDF

- BeadArray vignette (Dunning et al 2014, same author group as ploscompbio paper above):
http://www.bioconductor.org/packages/release/data/experiment/vignettes/BeadArrayUseCases/inst/doc/BeadArrayUseCases.pdf

- Lumi package vignette:
http://www.bioconductor.org/packages/release/bioc/vignettes/lumi/inst/doc/lumi.pdf

#############################
Get text file data from the array facility including the following:
- Control probe file for each sample with:
    ProbeID, AVG_Signal, BEAD_STDERR, Avg_NBEADS, Detection Pval
- Sample probe file for each sample with:
    ProbeID, Symbol, AVG_Signal, BEAD_STDERR, Avg_NBEADS, Detection Pval
- Annotation columns including:
    SEARCH_KEY, ILMN_GENE, CHROMOSOME, DEFINITION, SYNONYMS

- For limma, see p. 13 for data objects created (eg EListRaw, EList, MArrayLM and TestResults) and p.14 for functions used (eg summary, dim, length, ncol, nrow, dimnames, rownames and colnames).

Illumina gene expression microarray analysis steps (Ritchie et al. 2014):

1) Data acquisition
2) Preprocessing and quality assessment
3) Background correction, normalisation, transformation and filtering
4) Experimental design matrix specification
5) Descriptive statistics
6) Differential gene expression analysis
7) Integration with other data (separate script)
  

#############################
Preliminaries

Script is intended to run from src location (eg "/ifs/devel/antoniob/projects/BEST-D")
with files containing data and output deposited in separate location (eg /ifs/projects/proj043/analysis.dir/gene_expression.dir).

Things to do before running:
  - Set working directories
  - Provide file names (if running one file (see read.ilmn function), or multiple files (create a summary file first, see read.ilmn.targets function))

Set working directory and file locations:
```{r}
working_dir <- ("/ifs/projects/antoniob/VD_1ry_cells.dir/analysis.dir/")
setwd(working_dir)
script_dir <- ("/ifs/devel/antoniob/projects/VD_1ry_cells.dir")
script_dir
script_file <- file.path(script_dir,"VD_1ry_cells_gene_expression.Rmd")
script_file
```

Direct output to file as well as printing to screen (plots aren't redirected though, each done separately). Input is not echoed to the output file either.
```{r}
output_file <- file(paste("R_sessions_output_",Sys.Date(),".txt", sep=""))
output_file
sink(output_file, append=TRUE, split=TRUE, type = c("output", "message"))

#If the script can run from end to end, use source() with echo to execute and save all input to the output file (and not truncate 150+ character lines):
#source(script_file, echo=TRUE, max.deparse.length=10000)

#Record start of session:
Sys.time()
```

Update packages if necessary and load them:
```{r}
#source("http://bioconductor.org/biocLite.R")
#biocLite("BiocUpgrade")
#biocLite("limma")
#biocLite("beadarray")
#biocLite("lumi")
#biocLite("illuminaHumanv4.db")
#biocLite("arrayQualityMetrics")
#biocLite("quantro")
library(limma)
library(beadarray)
library(lumi)
library(illuminaHumanv4.db)
library(arrayQualityMetrics)
library(RColorBrewer)
library(genefilter)
library(Biobase)
library(quantro)
library(minfi)
library(flashClust)
library(ggplot2)
```

#############################
1) Data acquisition:
  Raw data comprises one observation per pixel, per array.
  Bead-level data comprises one observation per bead, per array.
  Summary-level data comprises one observation per probe type, per sample
  (Ritchie et al. PLos Comp Bio, 2014)
  
  a) Bead-level data: intensity and location information for each bead on each BeadArray is available (eg txt files with this information plus other optional/recommended files such as .bab [compressed data from the txt files], raw TIFF image data, sdf files, targets file, metrics file, etc., for analysis with beadarray package). See pdf vignette (Dunning et al 2014) above, analysis not included here.
  
  b) Summary level data (typical): files after processing in the BeadStudio software, for analysis with limma, lumi and beadarray packages. Files can be at different levels of processing (intensities with/without background correction and/or normalised). Files include sample probe profile (text file as data-matrix with 48,000 rowswith non-normalised summary values as output by BeadStudio, required); control probe profile (text file with summarised data for each of the controls of each array used for diagnostics and calibration, recommended); targets file (user created text file with information on which sample was hybridised to each array, required if reading in multiple probe profiles). Files with normalised intensities typically end in avg and files with intensites per gene may also be available. Avoid these as well as Illumina background correction and normalisation.

Get probe summary profiles (containing the intensity data). Best to obtain intensities from GenomeStudio or BeadStudio without background correction or normalization. Probe summary files are tab-delimited and usually arrays processed at one time are written to a single file.
Also obtain profiles for the control probes from BeadStudio or GenomeStudio processed data.

After processing with BeadStudio, for each array probe profile files contain: 
  summarized expression level (AVG_Signal)
  standard error of the bead replicates (BEAD_STDERR)
  number of beads (Avg_NBEADS) 
  detection p-value (DetectionPval), estimation of the probability of a gene being detected above the background level

Set input files if all array results where saved to one file:
```{r}
#Sample_Probe_File <- readTargets("xxx_SampleProbeProfile.txt")
#Control_Probe_File <- readTargets("xxx_ControlProbeProfile.txt")
#Sample_Probe_File
#Control_Probe_File
```

Load and read the Illumina probe files (typically one per experiment containing multiple arrays with a separate control probe profile file output). An EListRaw object is created in limma and should hold ~50,127 rows and 6 columns. Each row specificies if it is a control or sample probe. 'xxx'$targets data frame specifies which samples were hybridised to each array. 

Columns will include source, E (with the expression value for each probe), genes, other, Detection Pval, targets.

```{r}
#read_files <- read.ilmn(files=Sample_Probe_File, ctrlfiles=Control_Probe_File, path=NULL, ctrlpath=NULL, probeid="PROBE_ID", annotation=c("SYMBOL", "SEARCH_KEY", "ILMN_GENE", "CHROMOSOME", "DEFINITION", "SYNONYMS"), expr="AVG_Signal", other.columns="Detection Pval", sep="\t", verbose=TRUE)
```

If multiple probe files need to be read use the read.ilmn.targets function (requires a summary file with probe profiles (one, or two columns if control probe files are available).

First create a tab-delimited file with two columns ("files" header= sample probe profiles and "ctrlfiles" header= control profiles):
```{r}
targets_file <- readTargets("targets_file.txt")
targets_file
```

Then read all files:
```{r}
#read_files <- read.ilmn.targets(targets=targets_file)
read_files <- read.ilmn.targets(targets=targets_file, path=NULL, ctrlpath=NULL, probeid="PROBE_ID", annotation=c("SYMBOL", "SEARCH_KEY", "ILMN_GENE", "CHROMOSOME", "DEFINITION", "SYNONYMS"), expr="AVG_Signal", other.columns="Detection Pval", sep="\t", verbose=TRUE)
```

#############################
2) Preprocessing and quality assessment

If available/possible, run per array signal-to-noise value plot (95th percentile of signal divided by the 5th percentile); spatial plots of the intensities across array surface to detect array artefacts; between sample comparison with bloxplots of intensities; and MDS plot to determine between sample differences (biological, batches, etc.) (see Ritchie et al. 2014 Fig 2 for examples)

Positive controls can be used to identify suspect arrays.
Negative control probes, which measure background signal on each array, can be used to assess the proportion of expressed probes that are present in a given sample (Beadarray vignette).


a) Descriptives

Look at summary information of the probe profiles:

```{r}
#Array dimensions:
  #Number of arrays match number of samples expected? ~570
  #Number of rows is expected number of probes? eg ~48,000
dim(read_files)
#All files were included and read?
read_files$targets
read_files$E[1:5, ]
#Number of negative and regular probes. Illumina BeadChip arrays contain 750~1600 negative control probes:
table(read_files$genes$Status)

#View expression values for first 5 columns, first 10 samples:
options(digits=5)
head(read_files$E[1:5,1:10])
#All samples:
head(read_files$other$Detection)

#See p-values for detection, these test whether each probe is more intense than the negative control probes. Small values indicate that the probe corresponds to true expression:
range(read_files$other$Detection)
#min(read_files$other$Detection)
#max(read_files$other$Detection)
mean(read_files$other$Detection)
median(read_files$other$Detection)
```

Examples for redirecting plots at ~hihg-resolution to a file:
See: 
http://stackoverflow.com/questions/7144118/how-to-save-a-plot-as-image-on-the-disk
http://www.r-bloggers.com/high-resolution-figures-in-r/

png("Plot3.png", width = 4, height = 4, units = 'in', res = 300)
plot(x, y) # Make plot
dev.off()

pdf("Plot3.pdf", width = 4, height = 4)
plot(x, y) # Make plot
dev.off()

Boxplots of intensities to assess dynamic range from each sample and identify outliers from signal distributions. The intensities vary from about 5 to 14 on the log2 scale:
```{r}
#Boxplots for x number of samples (run loop for random sets? Plot all separately?):
intensities_plot <- ("boxplots_of_intensities.png")
png(intensities_plot, width = 4, height = 4, units = 'in', res = 300)
boxplot(log2(read_files$E[,400:420]),range=0,ylab="log2 intensity", xlab="Array")
dev.off()
#All samples (too many to visualise for BEST-D):
#boxplot(log2(read_files$E),range=0,ylab="log2 intensity of probe intensities", xlab="Array")
```

Separate boxplots of regular probes and control probes to highlight unusual samples:
```{r}

```

MDS plots:
```{r}
intensities_MDS <- ("MDS_of_intensities.png")
png(intensities_MDS, width = 4, height = 4, units = 'in', res = 300)
#'Multidimensional scaling plot of probe intensities')
plotMDS(read_files$E, pch=1, label=read_files$)
dev.off()
```

The 'propexpr' function estimates the proportion of expressed probes in each array by comparing the empirical intensity distribution of the negative control probes with that of the regular probes. A mixture model is fitted to the data from each array to infer the intensity distribution of expressed probes and estimate the expressed proportion.

```{r}
#Get proportion of expressed probes and descriptives:
proportion <- propexpr(read_files)
head(proportion)
length(proportion)
range(proportion)
mean(proportion)
median(proportion)
quantile(proportion)

propexpr_plot <- ("boxplot_of_propexpr.png")
png(propexpr_plot, width = 4, height = 4, units = 'in', res = 300)
boxplot(proportion, ylab='Proportion of expressed probes', xlab='All samples')
dev.off()

#Arrays with low expression (which to exclude? what value is min?):
which_low <- which(proportion <= 0.25)
length(which_low)
proportion[which_low]

which_med <- which(proportion > 0.25 & proportion <= 0.75)
length(which_med)
proportion[which_med]

which_high <- which(proportion > 0.75)
length(which_high)
proportion[which_high]

#propexpr_plot_IQR <- ("boxplot_of_propexpr_IQR.png")
#png(propexpr_plot_IQR, width = 4, height = 4, units = 'in', res = 300)
#boxplot(proportion[which_low], proportion[which_med], proportion[which_high], ylab='Proportion of expressed probes')
#dev.off()

#Which samples to compare if any? Random subsets? Null hypothesis is that 
#t.test(proportion[-which_low], proportion[which_low])
```

The arrayQualityMetrics package collates quality assessment plots for summarized data created by beadarray to identify outlier arrays:
```{r}

```

#############################
3) Background correction, normalisation, transformation and filtering
  a) Background correction
    Non-background corrected, non-normalised, sample and control probe profiles and targets file.

Reading the control probe profiles is optional but recommended. If the control probe profiles are available, then the Illumina data can be favorably background corrected and normalized using the neqc or nec functions.

The package quantro tests whether quantile normalisation is appropriate for the given dataset:
http://www.bioconductor.org/packages/release/bioc/vignettes/quantro/inst/doc/quantro-vignette.pdf

```{r}
browseVignettes("quantro")

```


The neqc function performs normexp background correction using negative controls, then quantile normalizes and finally log2 transforms [see ]. It also automatically removes the control probes, leaving only the regular probes:
```{r}
run_neqc <- neqc(read_files)
dim(run_neqc)
```
    
  b) Normalisation
    Quantile approach is run already by limma's neqc function.
    VST and other approaches, discuss
    
  c) Transformation
    log2 transformation is run by neqc, see other approaches.

Other functions to normalise and  transform:
```{r}
#eset <- normaliseIllumina(eset, method="quantile", transform= "log2")
```

  d) Filtering (after normalisation, before ?)
    Usually based on annotation quality

Filter out probes that are not expressed. Keep probes that are expressed in at least three arrays according to a detection p-value of 5% (Limma vignette case study, p. 108):

```{r}
expressed <- rowSums(run_neqc$other$Detection < 0.05) >= 3
run_neqc_expressed <- run_neqc[expressed,]
dim(run_neqc_expressed)
```

Plot expressed probes in a multi-dimensional scaling plot:
```{r}
plot_run_neqc_expressed <- ("MDS_run_neqc_expressed.png")
png(plot_run_neqc_expressed, width = 4, height = 4, units = 'in', res = 300)
plotMDS(run_neqc_expressed, pch=1) #, labels=run_neqc_expressed$)
dev.off()

plot_run_neqc_expressed_by_targets <- ("MDS_run_neqc_expressed_by_targets.png")
png(plot_run_neqc_expressed_by_targets, width = 4, height = 4, units = 'in', res = 300)
plotMDS(run_neqc_expressed, pch=1, labels=run_neqc_expressed$targets[])
dev.off()

plot_run_neqc_expressed_by_sample <- ("MDS_run_neqc_expressed_by_targets.png")
png(plot_run_neqc_expressed_by_sample, width = 4, height = 4, units = 'in', res = 300)
plotMDS(run_neqc_expressed, pch=1, labels=run_neqc_expressed$)
dev.off()

#Plot expressed probes in a heatmap:
hmcol <- colorRampPalette(brewer.pal(9, "GnBu"))(100)
#t <- ExpressionSet(e, AnnotatedDataFrame(tab))
#rv <- rowVars(exprs(t))
#idx <- order(-rv)[1:40]
#heatmap(exprs(t)[idx, ], col = hmcol)

```



Annotate samples:
```{r}
## Manually (bad)
pData(eset)$condition <- factor(rep(c("ctl", "trt"), each=3))
## Better / more reproducible to do this by importing a csv/table than doing it manually. You've been warned.
pData <- read.csv("xxx/metadata.csv", header=TRUE, row.names=1)

# Optional: I use Illumina's annotation. You can annotate the probes yourself if you want.
# See http://www.bioconductor.org/help/workflows/annotation/annotation/
```

Remove probes that aren't annotated with a gene
```{r}
annotated <- !is.na((fData(eset)$SYMBOL))
table(annotated)
eset <- eset[annotated,]
rm(annotated)
```


??
Create an expressionset, to xxx
```{r}
eset <- readBeadSummaryData(dataFile=Sample_Probe_File, qcFile=Control_Probe_File,
                            ProbeID="PROBE_ID", controlID="ProbeID",
                            skip=0, qc.skip=0,
                            annoCols=c("SYMBOL", "DEFINITION", "SYNONYMS", "CHROMOSOME", "ILMN_GENE", "SEARCH_KEY"))
```
??


#############################
4) Experimental design matrix specification
  a) Paired (before vs after comparison)
  b) Two group comparison
    Placebo vs high dose, placebo vs low dose, low dose vs high dose
  c) Three group comparison
  d) Difference-in-difference estimator

## Make a design matrix
```{r}
```

## Make a contrast matrix
```{r}
```

??
# Some of limma's stuff downstream doesn't work with whatever kind
# of object that you get out of normaliseIllumina().
# I coerce it to an "ExpressionSet" and everything seems to work fine.
```{r}
class(eset) <- "ExpressionSet"
```
??


#############################
5) Descriptive statistics
  Proportion of expressed probes in a sample (mixture model with negative controls (propexpr))


#############################
6) Differential gene expression analysis
  Linear modelling using weights
  a) 


#############################
7) Integration with other data
  a) eQTL analysis
  b) Disease variant overlap
  c) Pathway analysis

Analyze with limma
```{r}
```

## analyze the normal way: lmFit(), contrasts.fit(), eBayes(), topTable() 
```{r}
```
